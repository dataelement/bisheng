from typing import Any, Dict, Optional, List

from langchain.memory import ConversationBufferWindowMemory
from langchain_core.messages import AIMessage, HumanMessage, get_buffer_string, BaseMessage
from pydantic import BaseModel, Field


class GraphState(BaseModel):
    """ All nodes Global State Management """

    # Store Chat History
    history_memory: Optional[ConversationBufferWindowMemory] = None

    # Global Variable Pool
    variables_pool: Dict[str, Dict[str, Any]] = Field(default_factory=dict, description='Global Variable Pool: {node_id: {key: value}}')

    def get_history_memory(self, count: int) -> str:
        """ Get chat history
        'Cause it's not.1Right.1, so rewrite buffer_as_str"""
        if not count:
            count = self.history_memory.k
        if count == 0:
            return ''
        messages = self.history_memory.chat_memory.messages[-count:]
        return get_buffer_string(
            messages,
            human_prefix=self.history_memory.human_prefix,
            ai_prefix=self.history_memory.ai_prefix,
        )

    def get_history_list(self, count: int) -> List[BaseMessage]:
        return self.history_memory.buffer_as_messages[-count:]


    def save_context(self, content: str, msg_sender: str) -> None:
        """  Save chat
        workflow In special cases, the process will have multiple rounds of interaction, so it is not one-to-one, reworking the message structure"""
        if msg_sender == 'human':
            self.history_memory.chat_memory.add_messages([HumanMessage(content=content)])
        elif msg_sender == 'AI':
            self.history_memory.chat_memory.add_messages([AIMessage(content=content)])

    def set_variable(self, node_id: str, key: str, value: Any):
        """ Put the data generated by the node into a global variable """
        if node_id not in self.variables_pool:
            self.variables_pool[node_id] = {}
        self.variables_pool[node_id][key] = value

    def get_variable(self, node_id: str, key: str, count: Optional[int] = None) -> Any:
        """ Get data from global variables """
        if node_id not in self.variables_pool:
            return None

        if key == 'chat_history':
            return self.get_history_memory(count=count)
        return self.variables_pool[node_id].get(key)

    def get_variable_by_str(self, contact_key: str, history_count: Optional[int] = None) -> Any:
        """
        Get data from global variables
        contact_key: node_id.key#index  #indexNot necessarily
        """
        tmp_list = contact_key.split('.', 1)
        node_id = tmp_list[0]
        var_key = tmp_list[1]
        variable_val_index = None
        if var_key.find('#') != -1:
            var_key, variable_val_index = var_key.split('#')
        variable_val = self.get_variable(node_id, var_key, history_count)

        # Handling of array variables
        if variable_val_index:
            if isinstance(variable_val, list):
                variable_val_index = int(variable_val_index)
                if len(variable_val) <= variable_val_index:
                    raise Exception(f'variable {contact_key} index out of range')
                return variable_val[variable_val_index]
            elif isinstance(variable_val, dict):
                return variable_val.get(variable_val_index)
            else:
                raise Exception(f'variable {contact_key} is not a list or dict, not support #index')

        return variable_val

    def set_variable_by_str(self, contact_key: str, value: Any):
        tmp_list = contact_key.split('.', 1)
        node_id = tmp_list[0]
        var_key = tmp_list[1]
        if var_key.find('#') != -1:
            var_key, variable_val_index = var_key.split('#')
            old_value = self.get_variable(node_id, var_key)
            if not old_value:
                old_value = {}
            old_value[variable_val_index] = value
            value = old_value
        self.set_variable(node_id, var_key, value)

    def get_all_variables(self) -> Dict[str, Any]:
        """ Get all variables,keyarenode_id.keyformat;  """
        ret = {}
        for node_id, node_variables in self.variables_pool.items():
            for key, value in node_variables.items():
                ret[f'{node_id}.{key}'] = self.get_variable(node_id, key)
                # get preset_question and custom_variables all keys
                if key in ['preset_question', 'custom_variables']:
                    for k, v in value.items():
                        ret[f'{node_id}.{key}#{k}'] = v
        return ret
